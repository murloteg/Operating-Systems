# Задачи на синхронизацию. Блок #2

## 2.3. Список с примитивами синхронизации.

<span style="font-size: 16px">
    Реализуйте односвязный список, хранящий строки длиной менее 100 символов, у которого с каждым элементом связан отдельный примитив синхронизации 
    (за основу можно взять реализацию списка, на котором построен очередь queue_t). такого списка может выглядеть, например, так:<br>
    <code>
    &nbsp;&nbsp;&nbsp;typedef struct _Node {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char value[100];<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct _Node*  next;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pthread_mutex_t sync;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;} Node;
            <br>
            <br>
    &nbsp;&nbsp;&nbsp;&nbsp;typedef struct _Storage {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Node *first;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;} Storage;<br>
    </code>
<ul>
    <li>
        Первый поток пробегает по всему хранилищу и ищет количество пар строк, идущих по возрастанию длины. Как только достигнут конец списка, поток инкрементирует глобальную переменную, в которой хранится, количество выполненных им итераций и сразу начинает новый поиск.
    </li>
    <li>
        Второй поток пробегает по всему хранилищу и ищет количество пар строк, идущих по убыванию длины. Как только достигнут конец списка, поток инкрементирует глобальную переменную, в которой хранится количество выполненных им итераций и сразу начинает новый поиск.
    </li>
    <li>
        Третий поток пробегает по всему хранилищу и ищет количество пар строк, имеющих одинаковую длину. Как только достигнут конец списка, поток инкрементирует глобальную переменную, в которой хранится количество выполненных им итераций и сразу начинает новый поиск.
    </li>
    <li>
        Запускает 3 потока, которые в непрерывном бесконечном цикле случайным образом проверяют - требуется ли переставлять соседние элементы списка (не значения) и выполняют перестановку. Каждая успешная попытка перестановки фиксируется в соответствующей глобальной переменной-счетчике.
    </li>
</ul>
<code>Про реализацию:</code>
<br>
Используйте для синхронизации доступа к элементам списка спинлоки, мутексы и блокировки чтения-записи.<br>
Понаблюдайте как изменяются (и изменяются ли) значения переменных счетчиков и объясните результат.
Проверьте для списков длины 100, 1000, 10000, 100000<br><br>
При реализации обратите внимание на следующие пункты:
<ul>
    <li>
        продумайте ваше решение, чтобы избежать race condition;
    </li>
    <li>
        необходимо блокировать все записи с данными которых производится работа. - при перестановке записей списка, необходимо блокировать три записи;
    </li>
    <li>
        чтобы избежать мертвых блокировок, примитивы записей, более близких к началу списка, всегда захватывайте раньше.
    </li>
</ul>
</span>
